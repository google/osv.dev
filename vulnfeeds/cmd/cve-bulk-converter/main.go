// Package main converts CVEs to OSV format in bulk.
package main

import (
	_ "embed"
	"encoding/json"
	"flag"
	"fmt"
	"log/slog"
	"os"
	"path/filepath"
	"slices"
	"strings"
	"sync"

	"github.com/go-git/go-git/v5"
	"github.com/google/osv/vulnfeeds/cvelist2osv"
	"github.com/google/osv/vulnfeeds/cves"
	"github.com/google/osv/vulnfeeds/utility/logger"
)

var (
	repoDir        = flag.String("cve_repo", "cvelistV5", "CVEListV5 directory path")
	localOutputDir = flag.String("out_dir", "cvelist2osv", "Path to output results.")
	years          = flag.String("years", "2021,2022,2023,2024,2025", "A comma-separated list of years to process.")
	workers        = flag.Int("workers", 30, "The number of concurrent workers to use for processing CVEs.")
	cnas           = flag.String("cnas", "", "A comma-separated list of CNAs to process. If not provided, defaults to cna_allowlist.txt.")
)

//go:embed cna_allowlist.txt
var cnaAllowlistData []byte

func main() {
	flag.Parse()
	logger.InitGlobalLogger()

	logger.Info("Commencing Linux CVE to OSV conversion run")
	if err := os.MkdirAll(*localOutputDir, 0755); err != nil {
		logger.Fatal("Failed to create local output directory", slog.Any("err", err))
	}

	jobs := make(chan string)
	var wg sync.WaitGroup
	var cnaList []string
	if *cnas != "" {
		cnaList = strings.Split(*cnas, ",")
	} else {
		for _, cna := range strings.Split(string(cnaAllowlistData), "\n") {
			cna = strings.TrimSpace(cna)
			if cna != "" {
				cnaList = append(cnaList, cna)
			}
		}
	}

	// Get the HEAD commit hash of the repo.
	commitHash, err := getHeadCommit(*repoDir)
	if err != nil {
		logger.Warn("Failed to get HEAD commit hash", slog.Any("err", err))
	}

	// Start the worker pool.
	for range *workers {
		wg.Add(1)
		go worker(&wg, jobs, *localOutputDir, cnaList, commitHash)
	}

	// Discover files and send them to the workers.
	logger.Info("Starting conversion of CVEs...")

	yearList := strings.Split(*years, ",")
	for _, year := range yearList {
		yearDir := filepath.Join(*repoDir, "cves", year)
		if _, err := os.Stat(yearDir); os.IsNotExist(err) {
			logger.Info("Directory for year not found, skipping", slog.String("year", year))
			continue
		}

		logger.Info("Processing CVEs for year", slog.String("year", year))
		err := filepath.Walk(yearDir, func(path string, info os.FileInfo, err error) error {
			if err != nil {
				return err
			}
			if !info.IsDir() && strings.HasSuffix(info.Name(), ".json") {
				jobs <- path
			}

			return nil
		})
		if err != nil {
			logger.Info("Error walking directory for year", slog.String("year", year), slog.Any("err", err))
		}
	}

	close(jobs)
	wg.Wait()
	logger.Info("Conversion run complete")
}

// worker is a function that processes CVE files from the jobs channel.
func worker(wg *sync.WaitGroup, jobs <-chan string, outDir string, cnas []string, commitHash string) {
	defer wg.Done()
	for path := range jobs {
		data, err := os.ReadFile(path)
		if err != nil {
			logger.Info("Failed to read file", slog.String("path", path), slog.Any("err", err))
			continue
		}

		var cve cves.CVE5
		if err := json.Unmarshal(data, &cve); err != nil {
			logger.Info("Failed to unmarshal JSON", slog.String("path", path), slog.Any("err", err))
			continue
		}

		if !slices.Contains(cnas, cve.Metadata.AssignerShortName) || cve.Metadata.State != "PUBLISHED" {
			continue
		}
		cveID := cve.Metadata.CVEID
		logger.Info("Processing "+string(cveID), slog.String("cve", string(cveID)))

		osvFile, errCVE := cvelist2osv.CreateOSVFile(cveID, outDir)
		metricsFile, errMetrics := cvelist2osv.CreateMetricsFile(cveID, outDir)
		if errCVE != nil || errMetrics != nil {
			logger.Fatal("File failed to be created for CVE", slog.String("cve", string(cveID)))
		}

		sourceLink := ""
		if commitHash != "" {
			idx := strings.Index(path, "cves/")
			if idx != -1 {
				relPath := path[idx:]
				sourceLink = fmt.Sprintf("https://github.com/CVEProject/cvelistV5/blob/%s/%s", commitHash, relPath)
			}
		}

		// Perform the conversion and export the results.
		if err = cvelist2osv.ConvertAndExportCVEToOSV(cve, osvFile, metricsFile, sourceLink); err != nil {
			logger.Warn("Failed to generate an OSV record", slog.String("cve", string(cveID)), slog.Any("err", err))
		} else {
			logger.Info("Generated OSV record for "+string(cveID), slog.String("cve", string(cveID)), slog.String("cna", cve.Metadata.AssignerShortName))
		}

		metricsFile.Close()
		osvFile.Close()
	}
}

func getHeadCommit(repoDir string) (string, error) {
	r, err := git.PlainOpen(repoDir)
	if err != nil {
		return "", err
	}
	ref, err := r.Head()
	if err != nil {
		return "", err
	}

	return ref.Hash().String(), nil
}
