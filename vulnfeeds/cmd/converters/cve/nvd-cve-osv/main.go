// nvd-cve-osv converts NVD CVEs to OSV format.
package main

import (
	"encoding/csv"
	"encoding/json"
	"errors"
	"flag"
	"fmt"
	"log/slog"
	"os"
	"path/filepath"
	"slices"
	"strings"

	"github.com/google/osv/vulnfeeds/conversion/nvd"
	"github.com/google/osv/vulnfeeds/cves"
	"github.com/google/osv/vulnfeeds/git"
	"github.com/google/osv/vulnfeeds/models"
	"github.com/google/osv/vulnfeeds/utility/logger"
)

var (
	jsonPath            = flag.String("nvd-json", "", "Path to NVD CVE JSON to examine.")
	parsedCPEDictionary = flag.String("cpe-repos", "", "Path to JSON mapping of CPEs to repos generated by cpe-repo-gen")
	outDir              = flag.String("out-dir", "", "Path to output results.")
	outFormat           = flag.String("out-format", "OSV", "Format to output {OSV,PackageInfo}")
)
var RepoTagsCache git.RepoTagsCache
var Metrics struct {
	TotalCVEs           int
	CVEsForApplications int
	CVEsForKnownRepos   int
	OSVRecordsGenerated int
	Outcomes            map[models.CVEID]models.ConversionOutcome // Per-CVE-ID record of conversion result.
}

func loadCPEDictionary(productToRepo *cves.VendorProductToRepoMap, f string) error {
	data, err := os.ReadFile(f)
	if err != nil {
		return err
	}

	return json.Unmarshal(data, &productToRepo)
}

// Output a CSV summarizing per-CVE how it was handled.
func outputOutcomes(outcomes map[models.CVEID]models.ConversionOutcome, reposForCVE map[models.CVEID][]string, directory string) error {
	outcomesFile, err := os.Create(filepath.Join(directory, "outcomes.csv"))
	if err != nil {
		return err
	}
	defer outcomesFile.Close()
	w := csv.NewWriter(outcomesFile)
	if err := w.Write([]string{"CVE", "outcome", "repos"}); err != nil {
		return err
	}
	for CVE, outcome := range outcomes {
		// It's conceivable to have more than one repo for a CVE, so concatenate them.
		r := ""
		if repos, ok := reposForCVE[CVE]; ok {
			r = strings.Join(repos, " ")
		}
		if err := w.Write([]string{string(CVE), outcome.String(), r}); err != nil {
			return err
		}
	}
	w.Flush()

	if err = w.Error(); err != nil {
		return err
	}

	return nil
}

func main() {
	flag.Parse()
	if !slices.Contains([]string{"OSV", "PackageInfo"}, *outFormat) {
		fmt.Fprintf(os.Stderr, "Unsupported output format: %s\n", *outFormat)
		os.Exit(1)
	}

	Metrics.Outcomes = make(map[models.CVEID]models.ConversionOutcome)

	logger.InitGlobalLogger()

	data, err := os.ReadFile(*jsonPath)
	if err != nil {
		logger.Fatal("Failed to open file", slog.Any("err", err)) // double check this is best practice output
	}

	var parsed models.CVEAPIJSON20Schema
	err = json.Unmarshal(data, &parsed)
	if err != nil {
		logger.Fatal("Failed to parse NVD CVE JSON", slog.Any("err", err))
	}

	VPRepoCache := make(cves.VendorProductToRepoMap)

	if *parsedCPEDictionary != "" {
		err = loadCPEDictionary(&VPRepoCache, *parsedCPEDictionary)
		if err != nil {
			logger.Fatal("Failed to load parsed CPE dictionary", slog.Any("err", err))
		}
		logger.Info("VendorProductToRepoMap cache has entries preloaded", slog.Int("count", len(VPRepoCache)))
	}

	// ReposForCVE := make(map[models.CVEID][]string)

	for _, cve := range parsed.Vulnerabilities {
		metrics := &models.ConversionMetrics{
			CVEID: cve.CVE.ID,
			CNA:   "nvd",
		}
		repos := nvd.FindRepos(cve,VPRepoCache,metrics)

		switch *outFormat {
		case "OSV":
			err = nvd.CVEToOSV(cve.CVE, repos, RepoTagsCache, *outDir,metrics)
		case "PackageInfo":
			err = nvd.CVEToPackageInfo(cve.CVE, repos, RepoTagsCache, *outDir)
		}
		// Parse this error to determine which failure mode it was
		if err != nil {
			logger.Warn("Failed to generate an OSV record", slog.String("cve", string(CVEID)), slog.Any("err", err))
			if errors.Is(err, ErrNoRanges) {
				Metrics.Outcomes[CVEID] = models.NoRanges
				continue
			}
			if errors.Is(err, ErrUnresolvedFix) {
				Metrics.Outcomes[CVEID] = models.FixUnresolvable
				continue
			}
			Metrics.Outcomes[CVEID] = models.ConversionUnknown

			continue
		}
		Metrics.OSVRecordsGenerated++
		Metrics.Outcomes[CVEID] = models.Successful
	}
	Metrics.TotalCVEs = len(parsed.Vulnerabilities)
	err = outputOutcomes(Metrics.Outcomes, ReposForCVE, *outDir)
	if err != nil {
		// Log entry with size 1.15M exceeds maximum size of 256.0K
		fmt.Fprintf(os.Stderr, "Failed to write out metrics: %v", err)
	}
	// Outcomes is too big to log, so zero it out.
	Metrics.Outcomes = nil
	logger.Info("Metrics", slog.String("path", filepath.Base(*jsonPath)), slog.Any("metrics", Metrics))
}
