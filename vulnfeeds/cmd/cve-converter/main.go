package main

import (
	"encoding/json"
	"flag"
	"log"
	"os"
	"path/filepath"
	"strings"
	"sync"

	"github.com/google/osv/vulnfeeds/cmd/cvelist2osv"
	"github.com/google/osv/vulnfeeds/cves"
	"github.com/google/osv/vulnfeeds/utility"
)

var Logger utility.LoggerWrapper

type PartialCVE struct {
	Metadata struct {
		ID       string `json:"cveId"`
		Assigner string `json:"assignerShortName"`
		State    string `json:"state"`
	} `json:"cveMetadata"`
}

const (
	extension = ".json"
)

func main() {
	// --- Configuration ---
	years := flag.String("years", "2022,2023,2024,2025", "A comma-separated list of years to process.")
	workers := flag.Int("workers", 10, "The number of concurrent workers to use for processing CVEs.")

	flag.Parse()
	// --- Main execution ---
	log.Println("Commencing Linux CVE to OSV conversion run")

	repoDir := "cvelistV5"

	// Prepare for processing.
	localOutputDir := "osv_output"
	if err := os.MkdirAll(localOutputDir, 0755); err != nil {
		log.Fatalf("Failed to create local output directory: %v", err)
	}

	jobs := make(chan string)
	var wg sync.WaitGroup

	// Start the worker pool.
	for i := 0; i < *workers; i++ {
		wg.Add(1)
		go worker(&wg, jobs, localOutputDir)
	}

	// Discover files and send them to the workers.
	log.Println("Starting conversion of Linux CVEs...")
	yearList := strings.Split(*years, ",")
	for _, year := range yearList {
		yearDir := filepath.Join(repoDir, "cves", year)
		if _, err := os.Stat(yearDir); os.IsNotExist(err) {
			log.Printf("Directory for year %s not found, skipping.", year)
			continue
		}

		log.Printf("Processing CVEs for year %s...", year)
		err := filepath.Walk(yearDir, func(path string, info os.FileInfo, err error) error {
			if err != nil {
				return err
			}
			if !info.IsDir() && strings.HasSuffix(info.Name(), ".json") {
				jobs <- path
			}
			return nil
		})
		if err != nil {
			log.Printf("Error walking directory for year %s: %v", year, err)
		}
	}

	close(jobs)
	wg.Wait()
	log.Println("Conversion run complete")
}

// worker is a function that processes CVE files from the jobs channel.
func worker(wg *sync.WaitGroup, jobs <-chan string, outDir string) {
	defer wg.Done()
	for path := range jobs {
		data, err := os.ReadFile(path)
		if err != nil {
			log.Printf("Failed to read file %s: %v", path, err)
			continue
		}

		var cve PartialCVE
		if err := json.Unmarshal(data, &cve); err != nil {
			log.Printf("Failed to unmarshal JSON from %s: %v", path, err)
			continue
		}

		if cve.Metadata.Assigner == "Linux" && cve.Metadata.State == "PUBLISHED" {
			log.Printf("Processing %s...", cve.Metadata.ID)
			var logCleanup func()
			Logger, logCleanup = utility.CreateLoggerWrapper("cvelist-osv")
			defer logCleanup()

			// Fully unmarshal as CVE5
			var cve cves.CVE5
			if err = json.Unmarshal(data, &cve); err != nil {
				Logger.Fatalf("Failed to parse CVEList CVE JSON: %v", err)
			}

			if err = cvelist2osv.ConvertAndExportCVEToOSV(cve, outDir); err != nil {
				Logger.Warnf("[%s]: Failed to generate an OSV record: %+v", cve.Metadata.CVEID, err)
			}
		}
	}
}
