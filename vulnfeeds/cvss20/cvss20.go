// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package cvss20

import (
	"encoding/json"
	"fmt"
	"reflect"
)

type AccessComplexityType string

const AccessComplexityTypeHIGH AccessComplexityType = "HIGH"
const AccessComplexityTypeLOW AccessComplexityType = "LOW"
const AccessComplexityTypeMEDIUM AccessComplexityType = "MEDIUM"

type AccessVectorType string

const AccessVectorTypeADJACENTNETWORK AccessVectorType = "ADJACENT_NETWORK"
const AccessVectorTypeLOCAL AccessVectorType = "LOCAL"
const AccessVectorTypeNETWORK AccessVectorType = "NETWORK"

type AuthenticationType string

const AuthenticationTypeMULTIPLE AuthenticationType = "MULTIPLE"
const AuthenticationTypeNONE AuthenticationType = "NONE"
const AuthenticationTypeSINGLE AuthenticationType = "SINGLE"

type CiaRequirementType string

const CiaRequirementTypeHIGH CiaRequirementType = "HIGH"
const CiaRequirementTypeLOW CiaRequirementType = "LOW"
const CiaRequirementTypeMEDIUM CiaRequirementType = "MEDIUM"
const CiaRequirementTypeNOTDEFINED CiaRequirementType = "NOT_DEFINED"

type CiaType string

const CiaTypeCOMPLETE CiaType = "COMPLETE"
const CiaTypeNONE CiaType = "NONE"
const CiaTypePARTIAL CiaType = "PARTIAL"

type CollateralDamagePotentialType string

const CollateralDamagePotentialTypeHIGH CollateralDamagePotentialType = "HIGH"
const CollateralDamagePotentialTypeLOW CollateralDamagePotentialType = "LOW"
const CollateralDamagePotentialTypeLOWMEDIUM CollateralDamagePotentialType = "LOW_MEDIUM"
const CollateralDamagePotentialTypeMEDIUMHIGH CollateralDamagePotentialType = "MEDIUM_HIGH"
const CollateralDamagePotentialTypeNONE CollateralDamagePotentialType = "NONE"
const CollateralDamagePotentialTypeNOTDEFINED CollateralDamagePotentialType = "NOT_DEFINED"

type CvssV20 struct {
	// AccessComplexity corresponds to the JSON schema field "accessComplexity".
	AccessComplexity *AccessComplexityType `json:"accessComplexity,omitempty" yaml:"accessComplexity,omitempty" mapstructure:"accessComplexity,omitempty"`

	// AccessVector corresponds to the JSON schema field "accessVector".
	AccessVector *AccessVectorType `json:"accessVector,omitempty" yaml:"accessVector,omitempty" mapstructure:"accessVector,omitempty"`

	// Authentication corresponds to the JSON schema field "authentication".
	Authentication *AuthenticationType `json:"authentication,omitempty" yaml:"authentication,omitempty" mapstructure:"authentication,omitempty"`

	// AvailabilityImpact corresponds to the JSON schema field "availabilityImpact".
	AvailabilityImpact *CiaType `json:"availabilityImpact,omitempty" yaml:"availabilityImpact,omitempty" mapstructure:"availabilityImpact,omitempty"`

	// AvailabilityRequirement corresponds to the JSON schema field
	// "availabilityRequirement".
	AvailabilityRequirement *CiaRequirementType `json:"availabilityRequirement,omitempty" yaml:"availabilityRequirement,omitempty" mapstructure:"availabilityRequirement,omitempty"`

	// BaseScore corresponds to the JSON schema field "baseScore".
	BaseScore ScoreType `json:"baseScore" yaml:"baseScore" mapstructure:"baseScore"`

	// CollateralDamagePotential corresponds to the JSON schema field
	// "collateralDamagePotential".
	CollateralDamagePotential *CollateralDamagePotentialType `json:"collateralDamagePotential,omitempty" yaml:"collateralDamagePotential,omitempty" mapstructure:"collateralDamagePotential,omitempty"`

	// ConfidentialityImpact corresponds to the JSON schema field
	// "confidentialityImpact".
	ConfidentialityImpact *CiaType `json:"confidentialityImpact,omitempty" yaml:"confidentialityImpact,omitempty" mapstructure:"confidentialityImpact,omitempty"`

	// ConfidentialityRequirement corresponds to the JSON schema field
	// "confidentialityRequirement".
	ConfidentialityRequirement *CiaRequirementType `json:"confidentialityRequirement,omitempty" yaml:"confidentialityRequirement,omitempty" mapstructure:"confidentialityRequirement,omitempty"`

	// EnvironmentalScore corresponds to the JSON schema field "environmentalScore".
	EnvironmentalScore *ScoreType `json:"environmentalScore,omitempty" yaml:"environmentalScore,omitempty" mapstructure:"environmentalScore,omitempty"`

	// Exploitability corresponds to the JSON schema field "exploitability".
	Exploitability *ExploitabilityType `json:"exploitability,omitempty" yaml:"exploitability,omitempty" mapstructure:"exploitability,omitempty"`

	// IntegrityImpact corresponds to the JSON schema field "integrityImpact".
	IntegrityImpact *CiaType `json:"integrityImpact,omitempty" yaml:"integrityImpact,omitempty" mapstructure:"integrityImpact,omitempty"`

	// IntegrityRequirement corresponds to the JSON schema field
	// "integrityRequirement".
	IntegrityRequirement *CiaRequirementType `json:"integrityRequirement,omitempty" yaml:"integrityRequirement,omitempty" mapstructure:"integrityRequirement,omitempty"`

	// RemediationLevel corresponds to the JSON schema field "remediationLevel".
	RemediationLevel *RemediationLevelType `json:"remediationLevel,omitempty" yaml:"remediationLevel,omitempty" mapstructure:"remediationLevel,omitempty"`

	// ReportConfidence corresponds to the JSON schema field "reportConfidence".
	ReportConfidence *ReportConfidenceType `json:"reportConfidence,omitempty" yaml:"reportConfidence,omitempty" mapstructure:"reportConfidence,omitempty"`

	// TargetDistribution corresponds to the JSON schema field "targetDistribution".
	TargetDistribution *TargetDistributionType `json:"targetDistribution,omitempty" yaml:"targetDistribution,omitempty" mapstructure:"targetDistribution,omitempty"`

	// TemporalScore corresponds to the JSON schema field "temporalScore".
	TemporalScore *ScoreType `json:"temporalScore,omitempty" yaml:"temporalScore,omitempty" mapstructure:"temporalScore,omitempty"`

	// VectorString corresponds to the JSON schema field "vectorString".
	VectorString string `json:"vectorString" yaml:"vectorString" mapstructure:"vectorString"`

	// CVSS Version
	Version CvssV20Version `json:"version" yaml:"version" mapstructure:"version"`
}

type CvssV20Version string

const CvssV20VersionA20 CvssV20Version = "2.0"

type ExploitabilityType string

const ExploitabilityTypeFUNCTIONAL ExploitabilityType = "FUNCTIONAL"
const ExploitabilityTypeHIGH ExploitabilityType = "HIGH"
const ExploitabilityTypeNOTDEFINED ExploitabilityType = "NOT_DEFINED"
const ExploitabilityTypePROOFOFCONCEPT ExploitabilityType = "PROOF_OF_CONCEPT"
const ExploitabilityTypeUNPROVEN ExploitabilityType = "UNPROVEN"

type RemediationLevelType string

const RemediationLevelTypeNOTDEFINED RemediationLevelType = "NOT_DEFINED"
const RemediationLevelTypeOFFICIALFIX RemediationLevelType = "OFFICIAL_FIX"
const RemediationLevelTypeTEMPORARYFIX RemediationLevelType = "TEMPORARY_FIX"
const RemediationLevelTypeUNAVAILABLE RemediationLevelType = "UNAVAILABLE"
const RemediationLevelTypeWORKAROUND RemediationLevelType = "WORKAROUND"

type ReportConfidenceType string

const ReportConfidenceTypeCONFIRMED ReportConfidenceType = "CONFIRMED"
const ReportConfidenceTypeNOTDEFINED ReportConfidenceType = "NOT_DEFINED"
const ReportConfidenceTypeUNCONFIRMED ReportConfidenceType = "UNCONFIRMED"
const ReportConfidenceTypeUNCORROBORATED ReportConfidenceType = "UNCORROBORATED"

type ScoreType float64

type TargetDistributionType string

const TargetDistributionTypeHIGH TargetDistributionType = "HIGH"
const TargetDistributionTypeLOW TargetDistributionType = "LOW"
const TargetDistributionTypeMEDIUM TargetDistributionType = "MEDIUM"
const TargetDistributionTypeNONE TargetDistributionType = "NONE"
const TargetDistributionTypeNOTDEFINED TargetDistributionType = "NOT_DEFINED"

var enumValues_AccessComplexityType = []interface{}{
	"HIGH",
	"MEDIUM",
	"LOW",
}
var enumValues_AccessVectorType = []interface{}{
	"NETWORK",
	"ADJACENT_NETWORK",
	"LOCAL",
}
var enumValues_AuthenticationType = []interface{}{
	"MULTIPLE",
	"SINGLE",
	"NONE",
}
var enumValues_CiaRequirementType = []interface{}{
	"LOW",
	"MEDIUM",
	"HIGH",
	"NOT_DEFINED",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ReportConfidenceType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ReportConfidenceType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ReportConfidenceType, v)
	}
	*j = ReportConfidenceType(v)
	return nil
}

var enumValues_ReportConfidenceType = []interface{}{
	"UNCONFIRMED",
	"UNCORROBORATED",
	"CONFIRMED",
	"NOT_DEFINED",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RemediationLevelType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_RemediationLevelType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_RemediationLevelType, v)
	}
	*j = RemediationLevelType(v)
	return nil
}

var enumValues_RemediationLevelType = []interface{}{
	"OFFICIAL_FIX",
	"TEMPORARY_FIX",
	"WORKAROUND",
	"UNAVAILABLE",
	"NOT_DEFINED",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ExploitabilityType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ExploitabilityType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ExploitabilityType, v)
	}
	*j = ExploitabilityType(v)
	return nil
}

var enumValues_ExploitabilityType = []interface{}{
	"UNPROVEN",
	"PROOF_OF_CONCEPT",
	"FUNCTIONAL",
	"HIGH",
	"NOT_DEFINED",
}
var enumValues_TargetDistributionType = []interface{}{
	"NONE",
	"LOW",
	"MEDIUM",
	"HIGH",
	"NOT_DEFINED",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TargetDistributionType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TargetDistributionType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TargetDistributionType, v)
	}
	*j = TargetDistributionType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CollateralDamagePotentialType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_CollateralDamagePotentialType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_CollateralDamagePotentialType, v)
	}
	*j = CollateralDamagePotentialType(v)
	return nil
}

var enumValues_CollateralDamagePotentialType = []interface{}{
	"NONE",
	"LOW",
	"LOW_MEDIUM",
	"MEDIUM_HIGH",
	"HIGH",
	"NOT_DEFINED",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CiaType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_CiaType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_CiaType, v)
	}
	*j = CiaType(v)
	return nil
}

var enumValues_CiaType = []interface{}{
	"NONE",
	"PARTIAL",
	"COMPLETE",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CiaRequirementType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_CiaRequirementType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_CiaRequirementType, v)
	}
	*j = CiaRequirementType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AuthenticationType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AuthenticationType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AuthenticationType, v)
	}
	*j = AuthenticationType(v)
	return nil
}

var enumValues_CvssV20Version = []interface{}{
	"2.0",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CvssV20Version) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_CvssV20Version {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_CvssV20Version, v)
	}
	*j = CvssV20Version(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AccessVectorType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AccessVectorType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AccessVectorType, v)
	}
	*j = AccessVectorType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AccessComplexityType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AccessComplexityType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AccessComplexityType, v)
	}
	*j = AccessComplexityType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CvssV20) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["baseScore"]; !ok || v == nil {
		return fmt.Errorf("field baseScore in CvssV20: required")
	}
	if v, ok := raw["vectorString"]; !ok || v == nil {
		return fmt.Errorf("field vectorString in CvssV20: required")
	}
	if v, ok := raw["version"]; !ok || v == nil {
		return fmt.Errorf("field version in CvssV20: required")
	}
	type Plain CvssV20
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CvssV20(plain)
	return nil
}
