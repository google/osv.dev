package main

import (
	"encoding/csv"
	"encoding/json"
	"errors"
	"flag"
	"fmt"
	"log"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"time"

	"golang.org/x/exp/slices"

	"github.com/google/osv/vulnfeeds/cmd/common"
	"github.com/google/osv/vulnfeeds/cves"
	"github.com/google/osv/vulnfeeds/git"
	"github.com/google/osv/vulnfeeds/models"
	"github.com/google/osv/vulnfeeds/utility"
	"github.com/google/osv/vulnfeeds/vulns"
)

type ConversionOutcome int

var ErrNoRanges = errors.New("no ranges")

var ErrUnresolvedFix = errors.New("fixes not resolved to commits")

func (c ConversionOutcome) String() string {
	return [...]string{"ConversionUnknown", "Successful", "Rejected", "NoSoftware", "NoRepos", "NoRanges", "FixUnresolvable"}[c]
}

const (
	extension = ".json"
)

const (
	// Set of enums for categorizing conversion outcomes.
	ConversionUnknown ConversionOutcome = iota // Shouldn't happen
	Successful                                 // It worked!
	Rejected                                   // The CVE was rejected
	NoSoftware                                 // The CVE had no CPEs relating to software (i.e. Operating Systems or Hardware).
	NoRepos                                    // The CPE Vendor/Product had no repositories derived for it.
	NoRanges                                   // No viable commit ranges could be calculated from the repository for the CVE's CPE(s).
	FixUnresolvable                            // Partial resolution of versions, resulting in a false positive.
)

var (
	jsonPath            = flag.String("cve_json", "", "Path to CVEList JSON to examine.")
	parsedCPEDictionary = flag.String("cpe_repos", "", "Path to JSON mapping of CPEs to repos generated by cpe-repo-gen")
	outDir              = flag.String("out_dir", "", "Path to output results.")
	outFormat           = flag.String("out_format", "OSV", "Format to output {OSV,PackageInfo}")
)
var Logger utility.LoggerWrapper
var RepoTagsCache git.RepoTagsCache
var Metrics struct {
	TotalCVEs           int
	CVEsForApplications int
	CVEsForKnownRepos   int
	OSVRecordsGenerated int
	Outcomes            map[cves.CVEID]ConversionOutcome // Per-CVE-ID record of conversion result.
}

// References with these tags have been found to contain completely unrelated
// repositories and can be misleading as to the software's true repository,
// Currently not used for this purpose due to undesired false positives
// reducing the number of valid records successfully converted.
var RefTagDenyList = []string{
	// "Exploit",
	// "Third Party Advisory",
	"Broken Link", // Actively ignore these though.
}

// VendorProducts known not to be Open Source software and causing
// cross-contamination of repo derivation between CVEs.
var VendorProductDenyList = []common.VendorProduct{
	// Three strikes and the entire netapp vendor is out...
	{"netapp", ""},
	// [CVE-2021-28957]: Incorrectly associates with github.com/lxml/lxml
	{"oracle", "zfs_storage_appliance_kit"},
	{"gradle", "enterprise"}, // The OSS repo gets mis-attributed via CVE-2020-15767
}

// formatDateTimeRFC3339 parses an ISO-like date string and returns RFC3339 format or original on error.
func formatDateTimeRFC3339(dateStr string) string {
	if dateStr == "" {
		return ""
	}
	// Try parsing common ISO8601 variations
	layouts := []string{
		time.RFC3339Nano,           // "2006-01-02T15:04:05.999999999Z07:00"
		time.RFC3339,               // "2006-01-02T15:04:05Z07:00"
		"2006-01-02T15:04:05Z",     // ISO 8601 UTC
		"2006-01-02T15:04:05.000Z", // Explicit milliseconds UTC
	}
	var t time.Time
	var err error
	for _, layout := range layouts {
		t, err = time.Parse(layout, dateStr)
		if err == nil {
			break // Parsed successfully
		}
	}

	if err != nil {
		fmt.Printf("Warning: Could not parse date string '%s': %v. Returning original.\n", dateStr, err)
		return dateStr // Return original if parsing fails
	}
	return t.UTC().Format(time.RFC3339) // Format in UTC RFC3339
}

// BORROWED FROM VULNS.GO
// FromCVE creates a minimal OSV object from a given CVEItem and id.
// Leaves affected and version fields empty to be filled in later with AddPkgInfo
func FromCVE(id cves.CVEID, cve cves.CVE5) (*vulns.Vulnerability, []string) {
	aliases, related := vulns.ExtractReferencedVulns(id, cves.CVEID(cve.Metadata.ID), cve.Containers.CNA.References)
	v := vulns.Vulnerability{
		ID:      string(id),
		Details: cves.EnglishDescription(cve.Containers.CNA.Descriptions),
		Aliases: aliases,
		Related: related,
	}
	var notes []string

	v.Published = formatDateTimeRFC3339(cve.Metadata.DatePublished)
	v.Modified = formatDateTimeRFC3339(cve.Metadata.DateUpdated)
	v.References = vulns.ClassifyReferences(cve.Containers.CNA.References)
	// v.AddSeverity(cve.Metrics)
	return &v, notes
}
func ExtractVersionInfo(cve cves.CVE5, validVersions []string, httpClient *http.Client) (v models.VersionInfo, notes []string) {
	for _, reference := range cve.Containers.CNA.References {
		// (Potentially faulty) Assumption: All viable Git commit reference links are fix commits.
		if commit, err := cves.ExtractGitCommit(reference.Url, models.Fixed, httpClient); err == nil {
			v.AffectedCommits = append(v.AffectedCommits, commit)
		}
	}

	gotVersions := false
	cna := cve.Containers.CNA

	for _, cveAff := range cna.Affected {

		for _, vInfo := range cveAff.Versions {
			if vInfo.Status != "affected" {
				continue
			}
			introduced := ""
			fixed := ""
			lastaffected := ""
			// TODO Clean up versions and add checks for natural language or bad syntax
			hasRange := vInfo.LessThan != "" || vInfo.LessThanOrEqual != ""
			if vInfo.LessThan != "" && vInfo.LessThan == vInfo.Version {
				fmt.Printf("Warning: lessThan (%s) is the same as introduced (%s)\n", vInfo.LessThan, vInfo.Version)
				// Only this specific version affected or up to this version
				hasRange = false
			}

			// SUPER NAIVE APPROACH
			if hasRange {
				if vInfo.Version != "" || vInfo.Version != "n/a" || vInfo.Version != "unknown" {
					introduced = vInfo.Version
				}
				if vInfo.LessThan != "" || vInfo.LessThan != "n/a" || vInfo.LessThan != "unknown" {
					fixed = vInfo.LessThan
				} else if vInfo.LessThanOrEqual != "" || vInfo.LessThanOrEqual != "n/a" || vInfo.LessThanOrEqual != "unknown" {
					lastaffected = vInfo.LessThanOrEqual
				}

				if introduced != "" && !cves.HasVersion(validVersions, introduced) {
					notes = append(notes, fmt.Sprintf("Warning: %s is not a valid introduced version", introduced))
				}

				if fixed != "" && !cves.HasVersion(validVersions, fixed) {
					notes = append(notes, fmt.Sprintf("Warning: %s is not a valid fixed version", fixed))
				}

			} else {

				// only version number
				// naive assumption: it only affects that version. More likely, it affects up to that version
				// lastaffected = vInfo.Version
				v.AffectedVersions, _ = cves.ExtractVersionsFromDescription(validVersions, vInfo.Version)
				//check if it starts with "<" or "before" or "before version"

			}
			if introduced == "" && fixed == "" && lastaffected == "" {
				continue
			}
			gotVersions = true
			possibleNewAffectedVersion := models.AffectedVersion{
				Introduced:   introduced,
				Fixed:        fixed,
				LastAffected: lastaffected,
			}
			if slices.Contains(v.AffectedVersions, possibleNewAffectedVersion) {
				// Avoid appending duplicates
				continue
			}
			v.AffectedVersions = append(v.AffectedVersions, possibleNewAffectedVersion)
		}
	}
	if !gotVersions {
		var extractNotes []string
		v.AffectedVersions, extractNotes = cves.ExtractVersionsFromDescription(validVersions, cves.EnglishDescription(cve.Containers.CNA.Descriptions))
		notes = append(notes, extractNotes...)
		if len(v.AffectedVersions) > 0 {
			log.Printf("[%s] Extracted versions from description = %+v", cve.Metadata.ID, v.AffectedVersions)
		}
	}

	if len(v.AffectedVersions) == 0 {
		notes = append(notes, "No versions detected.")
	}

	if len(notes) != 0 && len(validVersions) > 0 {
		notes = append(notes, "Valid versions:")
		for _, version := range validVersions {
			notes = append(notes, "  - "+version)
		}
	}

	// Remove any lastaffected versions in favour of fixed versions.
	if v.HasFixedVersions() {
		affectedVersionsWithoutLastAffected := []models.AffectedVersion{}
		for _, av := range v.AffectedVersions {
			if av.LastAffected != "" {
				continue
			}
			affectedVersionsWithoutLastAffected = append(affectedVersionsWithoutLastAffected, av)
		}
		v.AffectedVersions = affectedVersionsWithoutLastAffected
	}
	return v, notes
}

// func extractVersFromWhateverIsGoingOnHere(line string) {
// 	// attempt to extract version from description
// 	// extract range from a bunch of arrows and shit
// 	versionsRaw := strings.Split(line, ",")
// 	var introVersion, lastAffVersion string
// 	for _, v := range versionsRaw {
// 		fmt.Println(v)
// 		v := strings.TrimSpace(v)

// 		// Split the version string by the comma and space to handle ranges.
// 		parts := strings.Split(v, ",")
// 		for part := range parts{
// 		for _, part := range parts {
// 			// Define a regular expression to extract the version and operator.
// 			pattern := regexp.MustCompile(`^([^<>=!]+)([<>=!]+)(.+)$`)
// 			matches := pattern.FindAllStringSubmatch(part, -1)
// 			if len(matches) > 0 {
// 				operator := matches[0][2]
// 				version := matches[0][3]
// 				fmt.Printf("Operator: %s, Version: %s\n", operator, version)
// 			}
// 		}
// 		if len(parts) == 2 {
// 			// Handles ranges like ">= 7.4.0, < 7.4.2"
// 			// Split at ">"

// 			if strings.Contains(parts[0], ">=") {
// 				lastAffVersion := strings.SplitAfter(parts[0], ">=")[1]
// 			} else if strings.Contains(parts[1], "<") {
// 				maxVersion = strings.TrimSpace(parts[1])
// 			}
// 		} else if len(parts) == 1 {
// 			// Handles single-ended ranges like "< 6.2.17"
// 			if strings.Contains(parts[0], "<") {
// 				maxVersion = strings.TrimSpace(parts[0])
// 			} else if strings.Contains(parts[0], ">") {
// 				minVersion = strings.TrimSpace(parts[0])
// 			}
// 		}

// 	}
// 	return introVersion, lastAffVersion
// }

// func ExtractVersionInfo(cve cves.CVE5, validVersions []string, httpClient *http.Client) (v models.VersionInfo, notes []string) {
// 	for _, reference := range cve.Containers.CNA.References {
// 		// (Potentially faulty) Assumption: All viable Git commit reference links are fix commits.
// 		if commit, err := cves.ExtractGitCommit(reference.Url, models.Fixed, httpClient); err == nil {
// 			v.AffectedCommits = append(v.AffectedCommits, commit)
// 		}
// 	}

// 	gotVersions := false
// 	cna := cve.Containers.CNA

// 	for _, cveAff := range cna.Affected {

// 		introduced := ""
// 		lastAffected := ""
// 		fixed := ""

// 		osvAff := AffectedInfo{
// 			Package: PackageInfo{
// 				Name:      cveAff.Product,
// 				Ecosystem: "Unknown", // Placeholder - CVE doesn't provide this directly
// 			},
// 			Ranges:   []vulns.Affected{},
// 			Versions: []string{},
// 		}

// 		specificVersions := []string{}
// 		hasRangeData := false

// 		for _, vInfo := range cveAff.Versions {
// 			if vInfo.Status != "affected" {
// 				continue
// 			}

// 			// TODO Clean up versions and add checks for natural language or bad syntax
// 			isRange := vInfo.LessThan != "" || vInfo.LessThanOrEqual != ""
// 			if vInfo.LessThan != "" && vInfo.LessThan == introduced {
// 				fmt.Printf("Warning: lessThan (%s) is the same as introduced (%s)\n", vInfo.LessThan, introduced)
// 				// Only this specific version affected or up to this version
// 				isRange = false
// 			}

// 			if isRange {
// 				hasRangeData = true
// 				rangeType := "SEMVER" // Default assumption
// 				if vInfo.VersionType != "" {
// 					rangeType = strings.ToUpper(vInfo.VersionType)
// 				}

// 				osvRange := AffectedRange{
// 					Type:   rangeType,
// 					Events: []RangeEvent{},
// 				}
// 				event := RangeEvent{}
// 				introducedSet := false
// 				if vInfo.Version != "" && (isRange || vInfo.Version == "0") {
// 					event.Introduced = vInfo.Version
// 					introducedSet = true
// 				}

// 				// If no specific start found, assume "0" for ranges unless it's clearly just one version affected
// 				if !introducedSet {
// 					// Heuristic: If there's an end condition, assume introduction from 0 if no start is given.
// 					if vInfo.LessThan != "" || vInfo.LessThanOrEqual != "" {
// 						event.Introduced = "0"
// 						introducedSet = true
// 					}
// 				}

// 				// Map end versions to 'fixed' or 'limit'
// 				if vInfo.LessThan != "" {
// 					event.Fixed = vInfo.LessThan
// 				} else if vInfo.LessThanOrEqual != "" {
// 					event.LastAffected = vInfo.LessThanOrEqual
// 					fmt.Printf("Warning: Mapping 'lessThanOrEqual' (%s) to OSV 'lastAffected'. OSV 'fixed' is preferred.\n", vInfo.LessThanOrEqual)
// 				}

// 				// Only add event if introduced or fixed/limit is set
// 				if event.Introduced != "" || event.Fixed != "" || event.LastAffected != "" {

// 					// OSV requires at least one event per range. Split into intro/fix events if both exist.
// 					if event.Introduced != "" {
// 						osvRange.Events = append(osvRange.Events, RangeEvent{Introduced: event.Introduced})
// 					}
// 					if event.Fixed != "" {
// 						osvRange.Events = append(osvRange.Events, RangeEvent{Fixed: event.Fixed})
// 					} else if event.LastAffected != "" {
// 						osvRange.Events = append(osvRange.Events, RangeEvent{LastAffected: event.lastAffected})
// 					}
// 					osvAff.Ranges = append(osvAff.Ranges, osvRange)
// 				}

// 			} else if vInfo.Version != "" && vInfo.Status == "affected" {
// 				// Check if this can first be parsed with natural language, e.g. 'before' or '<'

// 				// This looks like a specific vulnerable version listing
// 				specificVersions = append(specificVersions, vInfo.Version)
// 			}
// 		}

// 		// If we only found specific versions and no ranges, use the 'versions' field
// 		if len(specificVersions) > 0 && !hasRangeData {
// 			osvAff.Versions = specificVersions
// 			osvAff.Ranges = nil // Clear ranges if using specific versions
// 		} else if len(osvAff.Ranges) == 0 && len(specificVersions) > 0 {
// 			// Handle case where a version was listed but might have been misinterpreted as start of a range initially
// 			// If no ranges were actually formed, treat them as specific versions.
// 			osvAff.Versions = specificVersions
// 			osvAff.Ranges = nil
// 		}

// 		// Only add if there's meaningful affected data
// 		if len(osvAff.Ranges) > 0 || len(osvAff.Versions) > 0 {
// 			osv.Affected = append(osv.Affected, osvAff)

// 			gotVersions = true
// 			possibleNewAffectedVersion := models.AffectedVersion{
// 				Introduced:   introduced,
// 				Fixed:        fixed,
// 				LastAffected: lastAffected,
// 			}
// 			if slices.Contains(v.AffectedVersions, possibleNewAffectedVersion) {
// 				// Avoid appending duplicates
// 				continue
// 			}
// 			v.AffectedVersions = append(v.AffectedVersions, possibleNewAffectedVersion)
// 		}
// 	}

// 	if !gotVersions {
// 		var extractNotes []string
// 		v.AffectedVersions, extractNotes = extractVersionsFromDescription(validVersions, EnglishDescription(cve.Descriptions))
// 		notes = append(notes, extractNotes...)
// 		if len(v.AffectedVersions) > 0 {
// 			log.Printf("[%s] Extracted versions from description = %+v", cve.ID, v.AffectedVersions)
// 		}
// 	}

// 	if len(v.AffectedVersions) == 0 {
// 		notes = append(notes, "No versions detected.")
// 	}

// 	if len(notes) != 0 && len(validVersions) > 0 {
// 		notes = append(notes, "Valid versions:")
// 		for _, version := range validVersions {
// 			notes = append(notes, "  - "+version)
// 		}
// 	}

// 	// Remove any lastaffected versions in favour of fixed versions.
// 	if v.HasFixedVersions() {
// 		affectedVersionsWithoutLastAffected := []models.AffectedVersion{}
// 		for _, av := range v.AffectedVersions {
// 			if av.LastAffected != "" {
// 				continue
// 			}
// 			affectedVersionsWithoutLastAffected = append(affectedVersionsWithoutLastAffected, av)
// 		}
// 		v.AffectedVersions = affectedVersionsWithoutLastAffected
// 	}
// 	return v, notes
// }

// Takes a CVE record and outputs an OSV file in the specified directory.
func CVEToOSV(CVE cves.CVE5, repos []string, cache git.RepoTagsCache, directory string) error {
	// Create a base OSV record
	v, notes := FromCVE(cves.CVEID(CVE.Metadata.ID), CVE)

	// Extract Version Info
	// Rewrite this to extract version info for a CVE5
	versions, versionNotes := ExtractVersionInfo(CVE, nil, http.DefaultClient)

	notes = append(notes, versionNotes...)

	// Attempt to resolve Version Info to commits.
	cna := CVE.Containers.CNA
	maybeVendorName := "SOMETHING"
	maybeProductName := "SOMETHING"
	for _, cveAff := range cna.Affected {
		maybeVendorName = cveAff.Vendor
		maybeProductName = cveAff.Product
		continue
	}
	if len(versions.AffectedVersions) != 0 {
		var err error
		// There are some AffectedVersions to try and resolve to AffectedCommits.
		if len(repos) == 0 {
			return fmt.Errorf("[%s]: No affected ranges for %q, and no repos to try and convert %+v to tags with", CVE.Metadata.ID, maybeProductName, versions.AffectedVersions)
		}
		Logger.Infof("[%s]: Trying to convert version tags %+v to commits using %v", CVE.Metadata.ID, versions, repos)
		versions, err = common.GitVersionsToCommits(CVE.Metadata.ID, versions, repos, cache, Logger)
		if err != nil {
			return fmt.Errorf("[%s]: Failed to convert version tags to commits: %#v", CVE.Metadata.ID, err)
		}
		hasAnyFixedCommits := false
		for _, repo := range repos {
			if versions.HasFixedCommits(repo) {
				hasAnyFixedCommits = true
				break
			}
		}

		if versions.HasFixedVersions() && !hasAnyFixedCommits {
			return fmt.Errorf("[%s]: Failed to convert fixed version tags to commits: %#v %w", CVE.Metadata.ID, versions, ErrUnresolvedFix)
		}

		hasAnyLastAffectedCommits := false
		for _, repo := range repos {
			if versions.HasLastAffectedCommits(repo) {
				hasAnyLastAffectedCommits = true
				break
			}
		}

		if versions.HasLastAffectedVersions() && !hasAnyLastAffectedCommits && !hasAnyFixedCommits {
			return fmt.Errorf("[%s]: Failed to convert last_affected version tags to commits: %#v %w", CVE.Metadata.ID, versions, ErrUnresolvedFix)
		}
	}

	slices.SortStableFunc(versions.AffectedCommits, models.AffectedCommitCompare)

	affected := vulns.Affected{}
	affected.AttachExtractedVersionInfo(versions)
	v.Affected = append(v.Affected, affected)

	if len(v.Affected[0].Ranges) == 0 {
		return fmt.Errorf("[%s]: No affected ranges detected for %q %w", CVE.Metadata.ID, maybeProductName, ErrNoRanges)
	}

	// Save OSV record to a directory
	vulnDir := filepath.Join(directory, maybeVendorName, maybeProductName)
	err := os.MkdirAll(vulnDir, 0755)
	if err != nil {
		Logger.Warnf("Failed to create dir: %v", err)
		return fmt.Errorf("failed to create dir: %v", err)
	}

	outputFile := filepath.Join(vulnDir, v.ID+extension)
	notesFile := filepath.Join(vulnDir, v.ID+".notes")

	f, err := os.Create(outputFile)

	if err != nil {
		Logger.Warnf("Failed to open %s for writing: %v", outputFile, err)
		return fmt.Errorf("failed to open %s for writing: %v", outputFile, err)
	}
	defer f.Close()

	err = v.ToJSON(f)

	if err != nil {
		Logger.Warnf("Failed to write %s: %v", outputFile, err)
		return fmt.Errorf("failed to write %s: %v", outputFile, err)
	}
	Logger.Infof("[%s]: Generated OSV record for %q", CVE.Metadata.ID, maybeProductName)
	if len(notes) > 0 {
		err = os.WriteFile(notesFile, []byte(strings.Join(notes, "\n")), 0660)
		if err != nil {
			Logger.Warnf("[%s]: Failed to write %s: %v", CVE.Metadata.ID, notesFile, err)
		}
	}
	return nil
}

// Takes an NVD CVE record and outputs a PackageInfo struct in a file in the specified directory.
func CVEToPackageInfo(CVE cves.CVE5, repos []string, cache git.RepoTagsCache, directory string) error {
	// CPEs := cves.CPEs(CVE)
	// The vendor name and product name are used to construct the output `vulnDir` below, so need to be set to *something* to keep the output tidy.
	// maybeVendorName := "ENOCPE"
	// maybeProductName := "ENOCPE"

	// if len(CPEs) > 0 {
	// 	CPE, err := cves.ParseCPE(CPEs[0]) // For naming the subdirectory used for output.
	// 	maybeVendorName = CPE.Vendor
	// 	maybeProductName = CPE.Product
	// 	if err != nil {
	// 		return fmt.Errorf("[%s]: Can't generate an OSV record without valid CPE data", CVE.Metadata.ID)
	// 	}
	// }

	// // more often than not, this yields a VersionInfo with AffectedVersions and no AffectedCommits.
	// versions, notes := cves.ExtractVersionInfo(CVE, nil, http.DefaultClient)

	// if len(versions.AffectedVersions) != 0 {
	// 	var err error
	// 	// There are some AffectedVersions to try and resolve to AffectedCommits.
	// 	if len(repos) == 0 {
	// 		return fmt.Errorf("[%s]: No affected ranges for %q, and no repos to try and convert %+v to tags with", CVE.Metadata.ID, maybeProductName, versions.AffectedVersions)
	// 	}
	// 	Logger.Infof("[%s]: Trying to convert version tags %+v to commits using %v", CVE.Metadata.ID, versions, repos)
	// 	versions, err = GitVersionsToCommits(CVE.Metadata.ID, versions, repos, cache)
	// 	if err != nil {
	// 		return fmt.Errorf("[%s]: Failed to convert version tags to commits: %#v", CVE.Metadata.ID, err)
	// 	}
	// }

	// hasAnyFixedCommits := false
	// for _, repo := range repos {
	// 	if versions.HasFixedCommits(repo) {
	// 		hasAnyFixedCommits = true
	// 	}
	// }

	// if versions.HasFixedVersions() && !hasAnyFixedCommits {
	// 	return fmt.Errorf("[%s]: Failed to convert fixed version tags to commits: %#v %w", CVE.Metadata.ID, versions, ErrUnresolvedFix)
	// }

	// hasAnyLastAffectedCommits := false
	// for _, repo := range repos {
	// 	if versions.HasLastAffectedCommits(repo) {
	// 		hasAnyLastAffectedCommits = true
	// 	}
	// }

	// if versions.HasLastAffectedVersions() && !hasAnyLastAffectedCommits && !hasAnyFixedCommits {
	// 	return fmt.Errorf("[%s]: Failed to convert last_affected version tags to commits: %#v %w", CVE.Metadata.ID, versions, ErrUnresolvedFix)
	// }

	// if len(versions.AffectedCommits) == 0 {
	// 	return fmt.Errorf("[%s]: No affected commit ranges determined for %q %w", CVE.Metadata.ID, maybeProductName, ErrNoRanges)
	// }

	// versions.AffectedVersions = nil // these have served their purpose and are not required in the resulting output.

	// slices.SortStableFunc(versions.AffectedCommits, models.AffectedCommitCompare)

	// var pkgInfos []vulns.PackageInfo
	// pi := vulns.PackageInfo{VersionInfo: versions}
	// pkgInfos = append(pkgInfos, pi) // combine-to-osv expects a serialised *array* of PackageInfo

	// vulnDir := filepath.Join(directory, maybeVendorName, maybeProductName)
	// err := os.MkdirAll(vulnDir, 0755)
	// if err != nil {
	// 	Logger.Warnf("Failed to create dir: %v", err)
	// 	return fmt.Errorf("failed to create dir: %v", err)
	// }

	// outputFile := filepath.Join(vulnDir, string(CVE.Metadata.ID)+".nvd"+extension)
	// notesFile := filepath.Join(vulnDir, string(CVE.Metadata.ID)+".nvd.notes")
	// f, err := os.Create(outputFile)
	// if err != nil {
	// 	Logger.Warnf("Failed to open %s for writing: %v", outputFile, err)
	// 	return fmt.Errorf("failed to open %s for writing: %v", outputFile, err)
	// }
	// defer f.Close()

	// encoder := json.NewEncoder(f)
	// encoder.SetIndent("", "  ")
	// err = encoder.Encode(&pkgInfos)

	// if err != nil {
	// 	Logger.Warnf("Failed to encode PackageInfo to %s: %v", outputFile, err)
	// 	return fmt.Errorf("failed to encode PackageInfo to %s: %v", outputFile, err)
	// }

	// Logger.Infof("[%s]: Generated PackageInfo record for %q", CVE.ID, maybeProductName)

	// if len(notes) > 0 {
	// 	err = os.WriteFile(notesFile, []byte(strings.Join(notes, "\n")), 0660)
	// 	if err != nil {
	// 		Logger.Warnf("[%s]: Failed to write %s: %v", CVE.ID, notesFile, err)
	// 	}
	// }

	return nil
}

// Output a CSV summarizing per-CVE how it was handled.
func outputOutcomes(outcomes map[cves.CVEID]ConversionOutcome, reposForCVE map[cves.CVEID][]string, directory string) error {
	outcomesFile, err := os.Create(filepath.Join(directory, "outcomes.csv"))
	if err != nil {
		return err
	}
	defer outcomesFile.Close()
	w := csv.NewWriter(outcomesFile)
	w.Write([]string{"CVE", "outcome", "repos"})
	for CVE, outcome := range outcomes {
		// It's conceivable to have more than one repo for a CVE, so concatenate them.
		r := ""
		if repos, ok := reposForCVE[CVE]; ok {
			r = strings.Join(repos, " ")
		}
		w.Write([]string{string(CVE), outcome.String(), r})
	}
	w.Flush()

	if err = w.Error(); err != nil {
		return err
	}
	return nil
}

func main() {
	flag.Parse()
	if !slices.Contains([]string{"OSV", "PackageInfo"}, *outFormat) {
		fmt.Fprintf(os.Stderr, "Unsupported output format: %s\n", *outFormat)
		os.Exit(1)
	}

	Metrics.Outcomes = make(map[cves.CVEID]ConversionOutcome)

	var logCleanup func()
	Logger, logCleanup = utility.CreateLoggerWrapper("cvelist-osv")
	defer logCleanup()

	data, err := os.ReadFile(*jsonPath)
	if err != nil {
		Logger.Fatalf("Failed to open file: %v", err) // double check this is best practice output
	}

	var cve cves.CVE5
	err = json.Unmarshal(data, &cve)
	if err != nil {
		Logger.Fatalf("Failed to parse CVEList CVE JSON: %v", err)
	}

	// VPRepoCache := make(VendorProductToRepoMap)

	ReposForCVE := make(map[cves.CVEID][]string)

	refs := cve.Containers.CNA.References
	// check if there are more references in the ADP
	for _, adp := range cve.Containers.ADP {
		if adp.References != nil {
			refs = append(refs, adp.References...)
		}
	}

	for _, affected := range cve.Containers.CNA.Affected {
		if affected.CollectionUrl != "" {
			refs = append(refs, cves.Reference{Url: affected.CollectionUrl})
		}
	}
	for _, ref := range refs {
		log.Printf(ref.Url)
	}

	CVEID := cve.Metadata.ID

	// Not rejecting cause we might be able to leverage other datasources

	if len(refs) > 0 {
		repos := common.ReposFromReferences(string(CVEID), nil, nil, refs, RefTagDenyList, Logger)
		if len(repos) == 0 {
			Logger.Warnf("[%s]: Failed to derive any repos", CVEID)
		}
		Logger.Infof("[%s]: Derived %q for CVE", CVEID, repos)
		ReposForCVE[CVEID] = repos
	}

	Logger.Infof("[%s]: Repos: %#v", CVEID, ReposForCVE[CVEID])

	switch *outFormat {
	case "OSV":
		err = CVEToOSV(cve, ReposForCVE[CVEID], RepoTagsCache, *outDir)
		// case "PackageInfo":
		// 	err = CVEToPackageInfo(cve.CVE, ReposForCVE[CVEID], RepoTagsCache, *outDir)
		// }
		// Parse this error to determine which failure mode it was
		if err != nil {
			Logger.Warnf("[%s]: Failed to generate an OSV record: %+v", CVEID, err)
			if errors.Is(err, ErrNoRanges) {
				Metrics.Outcomes[CVEID] = NoRanges

			}
			if errors.Is(err, ErrUnresolvedFix) {
				Metrics.Outcomes[CVEID] = FixUnresolvable

			}
			Metrics.Outcomes[CVEID] = ConversionUnknown

		}
		Metrics.OSVRecordsGenerated++
		Metrics.Outcomes[CVEID] = Successful

		// Metrics.TotalCVEs = len(parsed.Vulnerabilities)
		// err = outputOutcomes(Metrics.Outcomes, ReposForCVE, *outDir)
		if err != nil {
			// Log entry with size 1.15M exceeds maximum size of 256.0K
			fmt.Fprintf(os.Stderr, "Failed to write out metrics: %v", err)
		}
		// Outcomes is too big to log, so zero it out.
		Metrics.Outcomes = nil
		Logger.Infof("%s Metrics: %+v", filepath.Base(*jsonPath), Metrics)
	}

}
