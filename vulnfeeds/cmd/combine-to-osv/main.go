// package main combines CVEs and security advisories into OSV records.
package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"log/slog"
	"os"
	"path"
	"sort"
	"strings"
	"time"

	"github.com/google/osv/vulnfeeds/cves"
	"github.com/google/osv/vulnfeeds/utility/logger"
	"github.com/google/osv/vulnfeeds/vulns"
	"github.com/ossf/osv-schema/bindings/go/osvschema"
)

const (
	defaultCvePath        = "cve_jsons"
	defaultPartsInputPath = "parts"
	defaultOSVOutputPath  = "osv_output"
	defaultCVEListPath    = "."

	alpineEcosystem = "Alpine"
	debianEcosystem = "Debian"
)

func main() {
	logger.InitGlobalLogger()

	cvePath := flag.String("cvePath", defaultCvePath, "Path to CVE file")
	partsInputPath := flag.String("partsPath", defaultPartsInputPath, "Path to CVE file")
	osvOutputPath := flag.String("osvOutputPath", defaultOSVOutputPath, "Path to CVE file")
	cveListPath := flag.String("cveListPath", defaultCVEListPath, "Path to clone of https://github.com/CVEProject/cvelistV5")
	flag.Parse()

	err := os.MkdirAll(*cvePath, 0755)
	if err != nil {
		logger.Fatal("Can't create output path", slog.Any("err", err))
	}
	err = os.MkdirAll(*osvOutputPath, 0755)
	if err != nil {
		logger.Fatal("Can't create output path", slog.Any("err", err))
	}

	// Load CVE5 OSVs
	allCVE5 := loadOSV(*cve5Path)
	// Load NVD OSVs
	allNVD := loadOSV(*nvdPath)

	// nvdCVEs := vulns.LoadAllCVEs(defaultNVDOSVPath)
	debianCVEs, err := listBucketObjects("osv-test-debian-osv/debian-cve-osv")
	alpineCVEs, err := listBucketObjects("osv-test-cve-osv-conversion/alpine")

	noPkg := append(debianCVEs, alpineCVEs...)
	// Combine
	combinedData := combineIntoOSV(allCVE5, allNVD, noPkg)
	writeOSVFile(combinedData, *osvOutputPath)
}

// getModifiedTime gets the modification time of a given file
// This function assumes that the modified time on disk matches with it in GCS
func getModifiedTime(filePath string) (time.Time, error) {
	var emptyTime time.Time
	fileInfo, err := os.Stat(filePath)
	if err != nil {
		return emptyTime, err
	}
	parsedTime := fileInfo.ModTime()

	return parsedTime, err
}

// loadInnerParts loads second level folder for the loadParts function
//
// Parameters:
//   - innerPartInputPath: The inner part path, such as "parts/alpine"
//   - output: A map to store all PackageInfos for each CVE ID
//   - cvePartsModifiedTime: A map tracking the latest modification time of each CVE part files
func loadInnerParts(innerPartInputPath string, output map[cves.CVEID][]vulns.PackageInfo, cvePartsModifiedTime map[cves.CVEID]time.Time) {
	dirInner, err := os.ReadDir(innerPartInputPath)
	if err != nil {
		logger.Fatal("Failed to read dir", slog.String("path", innerPartInputPath), slog.Any("err", err))
	}
	for _, entryInner := range dirInner {
		if !strings.HasSuffix(entryInner.Name(), ".json") {
			continue
		}
		filePath := path.Join(innerPartInputPath, entryInner.Name())
		file, err := os.Open(filePath)
		if err != nil {
			logger.Fatal("Failed to open PackageInfo JSON", slog.String("path", path.Join(innerPartInputPath, entryInner.Name())), slog.Any("err", err))
		}
		defer file.Close()
		var pkgInfos []vulns.PackageInfo
		err = json.NewDecoder(file).Decode(&pkgInfos)
		if err != nil {
			logger.Fatal("Failed to decode", slog.String("file", file.Name()), slog.Any("err", err))
		}

		// Turns CVE-2022-12345.alpine.json into CVE-2022-12345
		cveID := cves.CVEID(strings.Split(entryInner.Name(), ".")[0])
		output[cveID] = append(output[cveID], pkgInfos...)

		logger.Info("Loaded "+entryInner.Name(), slog.String("file", entryInner.Name()))

		// Updates the latest OSV parts modified time of each CVE
		modifiedTime, err := getModifiedTime(filePath)
		if err != nil {
			logger.Warn("Failed to get modified time", slog.String("path", filePath), slog.Any("err", err))
			continue
		}
		existingDate, exists := cvePartsModifiedTime[cveID]
		if !exists || modifiedTime.After(existingDate) {
			cvePartsModifiedTime[cveID] = modifiedTime
		}
	}
}

// loadParts loads files generated by other executables in the cmd folder.
//
// Expects directory structure of:
//
// - <partsInputPath>/
//   - alpineParts/
//   - CVE-2020-1234.alpine.json
//   - ...
//   - debianParts/
//   - ...
//
// ## Returns
// A mapping of "CVE-ID": []<Affected Package Information>
// A mapping of "CVE-ID": time.Time (the latest modified time of its part files)
func loadParts(partsInputPath string) (map[cves.CVEID][]vulns.PackageInfo, map[cves.CVEID]time.Time) {
	dir, err := os.ReadDir(partsInputPath)
	if err != nil {
		logger.Fatal("Failed to read dir", slog.String("path", partsInputPath), slog.Any("err", err))
	}
	output := map[cves.CVEID][]vulns.PackageInfo{}
	cvePartsModifiedTime := make(map[cves.CVEID]time.Time)
	for _, entry := range dir {
		if !entry.IsDir() {
			logger.Warn("Unexpected file entry", slog.String("file", entry.Name()), slog.String("path", partsInputPath))
			continue
		}
		// map is already a reference type, so no need to pass in a pointer
		loadInnerParts(path.Join(partsInputPath, entry.Name()), output, cvePartsModifiedTime)
	}

	return output, cvePartsModifiedTime
}

// combineIntoOSV creates OSV entry by combining loaded CVEs from NVD and PackageInfo information from security advisories.
func combineIntoOSV(cve5osv map[cves.CVEID]osvschema.Vulnerability, nvdosv map[cves.CVEID]osvschema.Vulnerability, debianCVEs []string) map[cves.CVEID]osvschema.Vulnerability {
	vulns := make(map[cves.CVEID]osvschema.Vulnerability)

	// Iterate through CVEs from security advisories (cve5) as the base
	for cveID, cve5 := range cve5osv {
		combined := cve5 // Start with the cve5 record
		nvd, ok := nvdosv[cveID]

		if ok {
			// If the cve5-derived record has no affected packages, use NVD's.
			if len(combined.Affected) == 0 && len(nvd.Affected) > 0 {
				combined.Affected = nvd.Affected
			}
			pickAffectedInformation(&combined.Affected, nvd.Affected)
			// TODO: if both NVD and CVE5 data exists, compare each affected range and make good decisions

			// Merge references, ensuring no duplicates.
			refMap := make(map[string]bool)
			for _, r := range combined.References {
				refMap[r.URL] = true
			}
			for _, r := range nvd.References {
				if !refMap[r.URL] {
					combined.References = append(combined.References, r)
					refMap[r.URL] = true
				}
			}

			// Merge timestamps: latest modified, earliest published.
			cve5Modified := combined.Modified
			if nvd.Modified.After(cve5Modified) {
				combined.Modified = nvd.Modified
			}

			cve5Published := combined.Published
			if nvd.Published.Before(cve5Published) {
				combined.Published = nvd.Published
			}

			// Merge aliases, ensuring no duplicates.
			aliasMap := make(map[string]bool)
			for _, alias := range combined.Aliases {
				aliasMap[alias] = true
			}
		}

		for _, pkgInfo := range allParts[cveID] {
			// skip debian and alpine parts, but still write out the CVEs.
			if strings.HasPrefix(pkgInfo.Ecosystem, debianEcosystem) || strings.HasPrefix(pkgInfo.Ecosystem, alpineEcosystem) {
				continue
			}
		}
		vulns[cveID] = combined
	}

	// Add any remaining CVEs from NVD that were not in the advisory data.
	for cveID, nvd := range nvdosv {
		vulns[cveID] = nvd
		logger.Info("" + string(cveID))
	}

	return vulns
}

func pickAffectedInformation(affected *[]osvschema.Affected, nvdAffected []osvschema.Affected) {
	// Compare version information
	if len(*affected) == 1 && len(nvdAffected) == 1 {

	}

}

func affectedToSignature(a osvschema.Affected) string {
	var parts []string
	if a.Package.Ecosystem != "" && a.Package.Name != "" {
		parts = append(parts, fmt.Sprintf("pkg:%s/%s", a.Package.Ecosystem, a.Package.Name))
	}
	for _, r := range a.Ranges {
		var events []string
		for _, e := range r.Events {
			if e.Fixed != "" {
				events = append(events, fmt.Sprintf("intro:%s,fixed:%s", e.Introduced, e.Fixed))
			} else if e.LastAffected != "" {
				events = append(events, fmt.Sprintf("intro:%s,lastaff:%s", e.Introduced, e.LastAffected))
			}
		}
		sort.Strings(events)
		parts = append(parts, fmt.Sprintf("type:%s,events:[%s]", r.Type, strings.Join(events, ",")))
	}
	sort.Strings(parts)
	return strings.Join(parts, "|")
}

// writeOSVFile writes out the given osv objects into individual json files
func writeOSVFile(osvData map[cves.CVEID]*vulns.Vulnerability, osvOutputPath string) {
	for vID, osv := range osvData {
		file, err := os.OpenFile(path.Join(osvOutputPath, string(vID)+".json"), os.O_CREATE|os.O_RDWR, 0644)
		if err != nil {
			logger.Fatal("Failed to create/open file to write", slog.Any("err", err))
		}
		encoder := json.NewEncoder(file)
		encoder.SetIndent("", "  ")
		err = encoder.Encode(osv)
		if err != nil {
			logger.Fatal("Failed to encode OSVs")
		}
		file.Close()
	}

	logger.Info("Successfully written OSV files", slog.Int("count", len(osvData)))
}
