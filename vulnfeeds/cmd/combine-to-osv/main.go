// package main combines CVEs and security advisories into OSV records.
package main

import (
	"encoding/json"
	"flag"
	"log/slog"
	"net/url"
	"os"
	"path"
	"strings"
	"time"

	"github.com/google/osv/vulnfeeds/cves"
	"github.com/google/osv/vulnfeeds/utility/logger"
	"github.com/google/osv/vulnfeeds/vulns"
	"github.com/ossf/osv-schema/bindings/go/osvschema"
)

const (
	defaultCvePath        = "cve_jsons"
	defaultPartsInputPath = "parts"
	defaultOSVOutputPath  = "osv_output"
	defaultCVEListPath    = "."

	alpineEcosystem          = "Alpine"
	alpineSecurityTrackerURL = "https://security.alpinelinux.org/vuln"
	debianEcosystem          = "Debian"
	debianSecurityTrackerURL = "https://security-tracker.debian.org/tracker"
)

func main() {
	logger.InitGlobalLogger()

	cvePath := flag.String("cvePath", defaultCvePath, "Path to CVE file")
	partsInputPath := flag.String("partsPath", defaultPartsInputPath, "Path to CVE file")
	osvOutputPath := flag.String("osvOutputPath", defaultOSVOutputPath, "Path to CVE file")
	cveListPath := flag.String("cveListPath", defaultCVEListPath, "Path to clone of https://github.com/CVEProject/cvelistV5")
	flag.Parse()

	err := os.MkdirAll(*cvePath, 0755)
	if err != nil {
		logger.Fatal("Can't create output path", slog.Any("err", err))
	}
	err = os.MkdirAll(*osvOutputPath, 0755)
	if err != nil {
		logger.Fatal("Can't create output path", slog.Any("err", err))
	}

	allCves := loadAllCVEs(*cvePath)
	allParts, cveModifiedMap := loadParts(*partsInputPath)
	combinedData := combineIntoOSV(allCves, allParts, *cveListPath, cveModifiedMap)
	writeOSVFile(combinedData, *osvOutputPath)
}

// getModifiedTime gets the modification time of a given file
// This function assumes that the modified time on disk matches with it in GCS
func getModifiedTime(filePath string) (time.Time, error) {
	var emptyTime time.Time
	fileInfo, err := os.Stat(filePath)
	if err != nil {
		return emptyTime, err
	}
	parsedTime := fileInfo.ModTime()

	return parsedTime, err
}

// loadInnerParts loads second level folder for the loadParts function
//
// Parameters:
//   - innerPartInputPath: The inner part path, such as "parts/alpine"
//   - output: A map to store all PackageInfos for each CVE ID
//   - cvePartsModifiedTime: A map tracking the latest modification time of each CVE part files
func loadInnerParts(innerPartInputPath string, output map[cves.CVEID][]vulns.PackageInfo, cvePartsModifiedTime map[cves.CVEID]time.Time) {
	dirInner, err := os.ReadDir(innerPartInputPath)
	if err != nil {
		logger.Fatal("Failed to read dir", slog.String("path", innerPartInputPath), slog.Any("err", err))
	}
	for _, entryInner := range dirInner {
		if !strings.HasSuffix(entryInner.Name(), ".json") {
			continue
		}
		filePath := path.Join(innerPartInputPath, entryInner.Name())
		file, err := os.Open(filePath)
		if err != nil {
			logger.Fatal("Failed to open PackageInfo JSON", slog.String("path", path.Join(innerPartInputPath, entryInner.Name())), slog.Any("err", err))
		}
		defer file.Close()
		var pkgInfos []vulns.PackageInfo
		err = json.NewDecoder(file).Decode(&pkgInfos)
		if err != nil {
			logger.Fatal("Failed to decode", slog.String("file", file.Name()), slog.Any("err", err))
		}

		// Turns CVE-2022-12345.alpine.json into CVE-2022-12345
		cveID := cves.CVEID(strings.Split(entryInner.Name(), ".")[0])
		output[cveID] = append(output[cveID], pkgInfos...)

		logger.Info("Loaded "+entryInner.Name(), slog.String("file", entryInner.Name()))

		// Updates the latest OSV parts modified time of each CVE
		modifiedTime, err := getModifiedTime(filePath)
		if err != nil {
			logger.Warn("Failed to get modified time", slog.String("path", filePath), slog.Any("err", err))
			continue
		}
		existingDate, exists := cvePartsModifiedTime[cveID]
		if !exists || modifiedTime.After(existingDate) {
			cvePartsModifiedTime[cveID] = modifiedTime
		}
	}
}

// loadParts loads files generated by other executables in the cmd folder.
//
// Expects directory structure of:
//
// - <partsInputPath>/
//   - alpineParts/
//   - CVE-2020-1234.alpine.json
//   - ...
//   - debianParts/
//   - ...
//
// ## Returns
// A mapping of "CVE-ID": []<Affected Package Information>
// A mapping of "CVE-ID": time.Time (the latest modified time of its part files)
func loadParts(partsInputPath string) (map[cves.CVEID][]vulns.PackageInfo, map[cves.CVEID]time.Time) {
	dir, err := os.ReadDir(partsInputPath)
	if err != nil {
		logger.Fatal("Failed to read dir", slog.String("path", partsInputPath), slog.Any("err", err))
	}
	output := map[cves.CVEID][]vulns.PackageInfo{}
	cvePartsModifiedTime := make(map[cves.CVEID]time.Time)
	for _, entry := range dir {
		if !entry.IsDir() {
			logger.Warn("Unexpected file entry", slog.String("file", entry.Name()), slog.String("path", partsInputPath))
			continue
		}
		// map is already a reference type, so no need to pass in a pointer
		loadInnerParts(path.Join(partsInputPath, entry.Name()), output, cvePartsModifiedTime)
	}

	return output, cvePartsModifiedTime
}

// combineIntoOSV creates OSV entry by combining loaded CVEs from NVD and PackageInfo information from security advisories.
func combineIntoOSV(loadedCves map[cves.CVEID]cves.Vulnerability, allParts map[cves.CVEID][]vulns.PackageInfo, cveList string, cvePartsModifiedTime map[cves.CVEID]time.Time) map[cves.CVEID]*vulns.Vulnerability {
	logger.Info("Begin writing OSV files", slog.Int("count", len(allParts)))
	convertedCves := map[cves.CVEID]*vulns.Vulnerability{}
	for cveID, cve := range loadedCves {
		if len(allParts[cveID]) == 0 {
			continue
		}
		convertedCve := vulns.FromNVDCVE(cveID, cve.CVE)
		if len(cveList) > 0 {
			// Best-effort attempt to mark a disputed CVE as withdrawn.
			modified, err := vulns.CVEIsDisputed(convertedCve, cveList)
			if err != nil {
				logger.Warn("Unable to determine CVE dispute status", slog.String("id", convertedCve.ID), slog.Any("err", err))
			}
			if err == nil && !modified.IsZero() {
				convertedCve.DatabaseSpecific = make(map[string]any)
				convertedCve.DatabaseSpecific["isDisputed"] = true
			}
		}

		addedDebianURL := false
		addedAlpineURL := false
		for _, pkgInfo := range allParts[cveID] {
			convertedCve.AddPkgInfo(pkgInfo)
			if strings.HasPrefix(pkgInfo.Ecosystem, debianEcosystem) && !addedDebianURL {
				addReference(string(cveID), debianEcosystem, convertedCve)
				addedDebianURL = true
			} else if strings.HasPrefix(pkgInfo.Ecosystem, alpineEcosystem) && !addedAlpineURL {
				addReference(string(cveID), alpineEcosystem, convertedCve)
				addedAlpineURL = true
			}
		}

		cveModified := convertedCve.Modified
		if cvePartsModifiedTime[cveID].After(cveModified) {
			convertedCve.Modified = cvePartsModifiedTime[cveID]
		}
		convertedCves[cveID] = convertedCve
	}
	logger.Info("Ended writing OSV files", slog.Int("count", len(convertedCves)))

	return convertedCves
}

// writeOSVFile writes out the given osv objects into individual json files
func writeOSVFile(osvData map[cves.CVEID]*vulns.Vulnerability, osvOutputPath string) {
	for vID, osv := range osvData {
		file, err := os.OpenFile(path.Join(osvOutputPath, string(vID)+".json"), os.O_CREATE|os.O_RDWR, 0644)
		if err != nil {
			logger.Fatal("Failed to create/open file to write", slog.Any("err", err))
		}
		encoder := json.NewEncoder(file)
		encoder.SetIndent("", "  ")
		err = encoder.Encode(osv)
		if err != nil {
			logger.Fatal("Failed to encode OSVs")
		}
		file.Close()
	}

	logger.Info("Successfully written OSV files", slog.Int("count", len(osvData)))
}

// loadAllCVEs loads the downloaded CVE's from the NVD database into memory.
func loadAllCVEs(cvePath string) map[cves.CVEID]cves.Vulnerability {
	dir, err := os.ReadDir(cvePath)
	if err != nil {
		logger.Fatal("Failed to read dir", slog.String("path", cvePath), slog.Any("err", err))
	}

	result := make(map[cves.CVEID]cves.Vulnerability)

	for _, entry := range dir {
		if !strings.HasSuffix(entry.Name(), ".json") {
			continue
		}
		file, err := os.Open(path.Join(cvePath, entry.Name()))
		if err != nil {
			logger.Fatal("Failed to open CVE JSON", slog.String("path", path.Join(cvePath, entry.Name())), slog.Any("err", err))
		}
		var nvdcve cves.CVEAPIJSON20Schema
		err = json.NewDecoder(file).Decode(&nvdcve)
		if err != nil {
			logger.Fatal("Failed to decode JSON", slog.String("file", file.Name()), slog.Any("err", err))
		}

		for _, item := range nvdcve.Vulnerabilities {
			result[item.CVE.ID] = item
		}
		logger.Info("Loaded CVE "+entry.Name(), slog.String("cve", entry.Name()))
		file.Close()
	}

	return result
}

// addReference adds the related security tracker URL to a given vulnerability's references
func addReference(cveID string, ecosystem string, convertedCve *vulns.Vulnerability) {
	securityReference := osvschema.Reference{Type: osvschema.ReferenceAdvisory}
	switch ecosystem {
	case alpineEcosystem:
		securityReference.URL, _ = url.JoinPath(alpineSecurityTrackerURL, cveID)
	case debianEcosystem:
		securityReference.URL, _ = url.JoinPath(debianSecurityTrackerURL, cveID)
	}

	if securityReference.URL == "" {
		return
	}

	convertedCve.References = append(convertedCve.References, securityReference)
}
