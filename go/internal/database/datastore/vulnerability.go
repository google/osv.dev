package datastore

import (
	"context"
	"errors"
	"fmt"
	"iter"
	"strings"

	"cloud.google.com/go/datastore"
	"github.com/google/osv.dev/go/internal/models"
	"google.golang.org/api/iterator"
)

type VulnerabilityStore struct {
	client *datastore.Client
}

var _ models.VulnerabilityStore = (*VulnerabilityStore)(nil)

func NewVulnerabilityStore(client *datastore.Client) *VulnerabilityStore {
	return &VulnerabilityStore{client: client}
}

func (s *VulnerabilityStore) ListBySource(ctx context.Context, source string, skipWithdrawn bool) iter.Seq2[*models.VulnSourceRef, error] {
	return func(yield func(*models.VulnSourceRef, error) bool) {
		// Mimic Python logic: filter by source_id prefix "source:"
		// In Datastore, prefix queries are done with >= prefix and < prefix + high-char
		prefix := source + ":"
		end := source + ";"

		q := datastore.NewQuery("Vulnerability").
			FilterField("source_id", ">=", prefix).
			FilterField("source_id", "<", end)

		if skipWithdrawn {
			q = q.FilterField("is_withdrawn", "=", false)
		}

		it := s.client.Run(ctx, q)
		for {
			var v Vulnerability
			key, err := it.Next(&v)
			if errors.Is(err, iterator.Done) {
				return
			}
			if err != nil {
				yield(nil, fmt.Errorf("failed to fetch vulnerability: %w", err))
				return
			}

			// source_id is in format "source:path"
			_, path, _ := strings.Cut(v.SourceID, ":")

			entry := &models.VulnSourceRef{
				ID:     key.Name,
				Source: source,
				Path:   path,
			}

			if !yield(entry, nil) {
				return
			}
		}
	}
}
