// nvd-cve-osv converts NVD CVEs to OSV format.
package main

import (
	"encoding/json"
	"errors"
	"flag"
	"fmt"
	"log/slog"
	"os"
	"slices"
	"sync"

	"github.com/google/osv/vulnfeeds/conversion/nvd"
	"github.com/google/osv/vulnfeeds/cves"
	"github.com/google/osv/vulnfeeds/git"
	"github.com/google/osv/vulnfeeds/models"
	"github.com/google/osv/vulnfeeds/utility/logger"
)

var (
	jsonPath            = flag.String("nvd-json", "", "Path to NVD CVE JSON to examine.")
	parsedCPEDictionary = flag.String("cpe-repos", "", "Path to JSON mapping of CPEs to repos generated by cpe-repo-gen")
	outDir              = flag.String("out-dir", "", "Path to output results.")
	outFormat           = flag.String("out-format", "OSV", "Format to output {OSV,PackageInfo}")
	workers             = flag.Int("workers", 30, "The number of concurrent workers to use for processing CVEs.")
)

func loadCPEDictionary(productToRepo *cves.VPRepoCache, f string) error {
	data, err := os.ReadFile(f)
	if err != nil {
		return err
	}

	var tempMap cves.VendorProductToRepoMap
	if err := json.Unmarshal(data, &tempMap); err != nil {
		return err
	}
	productToRepo.Import(tempMap)

	return nil
}

func main() {
	flag.Parse()
	if !slices.Contains([]string{"OSV", "PackageInfo"}, *outFormat) {
		fmt.Fprintf(os.Stderr, "Unsupported output format: %s\n", *outFormat)
		os.Exit(1)
	}

	logger.InitGlobalLogger()

	data, err := os.ReadFile(*jsonPath)
	if err != nil {
		logger.Fatal("Failed to open file", slog.Any("err", err)) // double check this is best practice output
	}

	var parsed models.CVEAPIJSON20Schema
	err = json.Unmarshal(data, &parsed)
	if err != nil {
		logger.Fatal("Failed to parse NVD CVE JSON", slog.Any("err", err))
	}

	vpRepoCache := cves.NewVPRepoCache()
	if *parsedCPEDictionary != "" {
		err = loadCPEDictionary(vpRepoCache, *parsedCPEDictionary)
		if err != nil {
			logger.Fatal("Failed to load parsed CPE dictionary", slog.Any("err", err))
		}
		logger.Info("VendorProductToRepoMap cache has entries preloaded")
	}

	repoTagsCache := &git.RepoTagsCache{}

	jobs := make(chan models.NVDCVE)
	var wg sync.WaitGroup

	for range *workers {
		wg.Add(1)
		go worker(&wg, jobs, *outDir, vpRepoCache, repoTagsCache)
	}

	for _, cve := range parsed.Vulnerabilities {
		jobs <- cve.CVE
	}

	close(jobs)
	wg.Wait()
	logger.Info("NVD Conversion run complete")
}

func processCVE(cve models.NVDCVE, vpRepoCache *cves.VPRepoCache, repoTagsCache *git.RepoTagsCache) error {
	metrics := &models.ConversionMetrics{
		CVEID: cve.ID,
		CNA:   "nvd",
	}
	repos := nvd.FindRepos(cve, vpRepoCache, metrics)
	metrics.Repos = repos

	var err error
	switch *outFormat {
	case "OSV":
		err = nvd.CVEToOSV(cve, repos, repoTagsCache, *outDir, metrics)
	case "PackageInfo":
		err = nvd.CVEToPackageInfo(cve, repos, repoTagsCache, *outDir, metrics)
	}
	// Parse this error to determine which failure mode it was
	if err != nil {
		logger.Warn("Failed to generate an OSV record", slog.String("cve", string(cve.ID)), slog.Any("err", err))
		if errors.Is(err, nvd.ErrNoRanges) {
			metrics.Outcome = models.NoRanges
			return err
		}
		if errors.Is(err, nvd.ErrUnresolvedFix) {
			metrics.Outcome = models.FixUnresolvable
			return err
		}
		metrics.Outcome = models.ConversionUnknown

		return err
	}
	metrics.Outcome = models.Successful

	return nil
}

func worker(wg *sync.WaitGroup, jobs <-chan models.NVDCVE, _ string, vpRepoCache *cves.VPRepoCache, repoTagsCache *git.RepoTagsCache) {
	defer wg.Done()
	for cve := range jobs {
		if err := processCVE(cve, vpRepoCache, repoTagsCache); err != nil {
			logger.Warn("Failed to generate an OSV record", slog.String("cve", string(cve.ID)), slog.Any("err", err))
		} else {
			logger.Info("Generated OSV record for "+string(cve.ID), slog.String("cve", string(cve.ID)))
		}
	}
}
