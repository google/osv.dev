// nvd-cve-osv converts NVD CVEs to OSV format.
package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"log/slog"
	"net/http"
	"os"
	"path/filepath"
	"regexp"
	"runtime/pprof"
	"slices"
	"sync"

	"github.com/google/osv/vulnfeeds/conversion"
	"github.com/google/osv/vulnfeeds/conversion/nvd"
	"github.com/google/osv/vulnfeeds/cves"
	"github.com/google/osv/vulnfeeds/git"
	"github.com/google/osv/vulnfeeds/models"
	"github.com/google/osv/vulnfeeds/utility/logger"
)

var (
	jsonPath            = flag.String("nvd-json", "", "Path to NVD CVE JSON to examine.")
	parsedCPEDictionary = flag.String("cpe-repos", "", "Path to JSON mapping of CPEs to repos generated by cpe-repo-gen")
	outDir              = flag.String("out-dir", "", "Path to output results.")
	outFormat           = flag.String("out-format", "OSV", "Format to output {OSV,PackageInfo}")
	workers             = flag.Int("workers", 30, "The number of concurrent workers to use for processing CVEs.")
	rejectFailed        = flag.Bool("reject-failed", false, "If set, OSV records with a failed conversion outcome will not be generated.")
	outputMetrics       = flag.Bool("output-metrics", true, "If true, output the metrics information about the conversion")
	cpuProfile          = flag.String("cpuprofile", "", "write cpu profile to file")
)

func loadCPEDictionary(productToRepo *cves.VPRepoCache, f string) error {
	data, err := os.ReadFile(f)
	if err != nil {
		return err
	}

	var tempMap cves.VendorProductToRepoMap
	if err := json.Unmarshal(data, &tempMap); err != nil {
		return err
	}
	productToRepo.Initialize(tempMap)

	return nil
}

func main() {
	flag.Parse()
	if !slices.Contains([]string{"OSV", "PackageInfo"}, *outFormat) {
		fmt.Fprintf(os.Stderr, "Unsupported output format: %s\n", *outFormat)
		os.Exit(1)
	}

	if *cpuProfile != "" {
		f, err := os.Create(*cpuProfile)
		if err != nil {
			logger.Fatal("could not create CPU profile: ", slog.Any("err", err))
		}
		defer f.Close()
		if err := pprof.StartCPUProfile(f); err != nil {
			logger.Fatal("could not start CPU profile: ", slog.Any("err", err))
		}
		defer pprof.StopCPUProfile()
	}

	logger.InitGlobalLogger()

	data, err := os.ReadFile(*jsonPath)
	if err != nil {
		logger.Fatal("Failed to open file", slog.Any("err", err)) // double check this is best practice output
	}

	var parsed models.CVEAPIJSON20Schema
	err = json.Unmarshal(data, &parsed)
	if err != nil {
		logger.Fatal("Failed to parse NVD CVE JSON", slog.Any("err", err))
	}

	vpRepoCache := cves.NewVPRepoCache()
	if *parsedCPEDictionary != "" {
		err = loadCPEDictionary(vpRepoCache, *parsedCPEDictionary)
		if err != nil {
			logger.Fatal("Failed to load parsed CPE dictionary", slog.Any("err", err))
		}
		logger.Info("VendorProductToRepoMap cache has entries preloaded")
	}

	repoTagsCache := &git.RepoTagsCache{}

	jobs := make(chan models.NVDCVE)
	var wg sync.WaitGroup

	for range *workers {
		wg.Add(1)
		go worker(&wg, jobs, *outDir, vpRepoCache, repoTagsCache)
	}

	for _, cve := range parsed.Vulnerabilities {
		jobs <- cve.CVE
	}

	close(jobs)
	wg.Wait()
	logger.Info("NVD Conversion run complete")

	// Conduct analysis on the outcome of the converted files and output to a csv
	if *outputMetrics {
		// Try to extract year from path, otherwise use "xxxx" filler
		filename := filepath.Base(*jsonPath)
		re := regexp.MustCompile(`nvdcve-2\.0-([0-9]{4})\.json`)
		matches := re.FindStringSubmatch(filename)
		if len(matches) >= 2 {
			year := matches[1]
			conversion.ConductAnalysis(year, *outDir)
		} else {
			conversion.ConductAnalysis("xxxx", *outDir)
		}
	}
}

func processCVE(cve models.NVDCVE, vpRepoCache *cves.VPRepoCache, repoTagsCache *git.RepoTagsCache) models.ConversionOutcome {
	metrics := &models.ConversionMetrics{
		CVEID: cve.ID,
		CNA:   "nvd",
	}
	repos := nvd.FindRepos(cve, vpRepoCache, repoTagsCache, metrics, http.DefaultClient)
	metrics.Repos = repos

	var outcome models.ConversionOutcome
	switch *outFormat {
	case "OSV":
		outcome = nvd.CVEToOSV(cve, repos, repoTagsCache, *outDir, metrics, *rejectFailed, *outputMetrics)
		// case "PackageInfo":
		// 	outcome = nvd.CVEToPackageInfo(cve, repos, repoTagsCache, *outDir, metrics, *rejectFailed)
	}

	return outcome
}

func worker(wg *sync.WaitGroup, jobs <-chan models.NVDCVE, _ string, vpRepoCache *cves.VPRepoCache, repoTagsCache *git.RepoTagsCache) {
	defer wg.Done()
	for cve := range jobs {
		if processCVE(cve, vpRepoCache, repoTagsCache) != models.Successful {
			logger.Info("Failed to generate an OSV record", slog.String("cve", string(cve.ID)))
		} else {
			logger.Info("Generated OSV record for "+string(cve.ID), slog.String("cve", string(cve.ID)))
		}
	}
}
