package main

import (
	"encoding/csv"
	"encoding/json"
	"flag"
	"log"
	"os"
	"path/filepath"
	"strings"
	"sync"

	"github.com/google/osv/vulnfeeds/cmd/cvelist2osv"
	"github.com/google/osv/vulnfeeds/cves"
	"github.com/google/osv/vulnfeeds/utility"
)

var Metrics struct {
	TotalCVEs           int
	CVEsForApplications int
	CVEsForKnownRepos   int
	OSVRecordsGenerated int
	Outcomes            map[cves.CVEID]ConversionOutcome // Per-CVE-ID record of conversion result.
}
var Logger utility.LoggerWrapper

// CVE represents the relevant fields from the CVE JSON format.
type CVE struct {
	Metadata struct {
		ID       string `json:"cveId"`
		Assigner string `json:"assignerShortName"`
		State    string `json:"state"`
	} `json:"cveMetadata"`
}
type ConversionOutcome int

func (c ConversionOutcome) String() string {
	return [...]string{"ConversionUnknown", "Successful", "Rejected", "NoSoftware", "NoRepos", "NoRanges", "FixUnresolvable"}[c]
}

const (
	extension = ".json"
)
const (
	// Set of enums for categorizing conversion outcomes.
	ConversionUnknown ConversionOutcome = iota // Shouldn't happen
	Successful                                 // It worked!
	Rejected                                   // The CVE was rejected
	NoSoftware                                 // The CVE had no CPEs relating to software (i.e. Operating Systems or Hardware).
	NoRepos                                    // The CPE Vendor/Product had no repositories derived for it.
	NoRanges                                   // No viable commit ranges could be calculated from the repository for the CVE's CPE(s).
	FixUnresolvable                            // Partial resolution of versions, resulting in a false positive.
)

// Output a CSV summarizing per-CVE how it was handled.
func outputOutcomes(outcomes map[cves.CVEID]ConversionOutcome, directory string) error {
	outcomesFile, err := os.Create(filepath.Join(directory, "outcomes.csv"))
	if err != nil {
		return err
	}
	defer outcomesFile.Close()
	w := csv.NewWriter(outcomesFile)
	w.Write([]string{"CVE", "outcome"})
	for CVE, outcome := range outcomes {
		// It's conceivable to have more than one repo for a CVE, so concatenate them.
		w.Write([]string{string(CVE), outcome.String()})
	}
	w.Flush()

	if err = w.Error(); err != nil {
		return err
	}
	return nil
}

func main() {
	// --- Configuration ---
	years := flag.String("years", "2022,2023,2024,2025", "A comma-separated list of years to process.")
	workers := flag.Int("workers", 10, "The number of concurrent workers to use for processing CVEs.")

	flag.Parse()
	Metrics.Outcomes = make(map[cves.CVEID]ConversionOutcome)
	// --- Main execution ---
	log.Println("Commencing Linux CVE to OSV conversion run")

	repoDir := "cvelistV5"

	// Prepare for processing.
	localOutputDir := "osv_output"
	if err := os.MkdirAll(localOutputDir, 0755); err != nil {
		log.Fatalf("Failed to create local output directory: %v", err)
	}

	jobs := make(chan string)
	var wg sync.WaitGroup

	// Start the worker pool.
	for i := 0; i < *workers; i++ {
		wg.Add(1)
		go worker(&wg, jobs, localOutputDir)
	}

	// Discover files and send them to the workers.
	log.Println("Starting conversion of Linux CVEs...")
	yearList := strings.Split(*years, ",")
	for _, year := range yearList {
		yearDir := filepath.Join(repoDir, "cves", year)
		if _, err := os.Stat(yearDir); os.IsNotExist(err) {
			log.Printf("Directory for year %s not found, skipping.", year)
			continue
		}

		log.Printf("Processing CVEs for year %s...", year)
		err := filepath.Walk(yearDir, func(path string, info os.FileInfo, err error) error {
			if err != nil {
				return err
			}
			if !info.IsDir() && strings.HasSuffix(info.Name(), ".json") {
				jobs <- path
			}
			return nil
		})
		if err != nil {
			log.Printf("Error walking directory for year %s: %v", year, err)
		}
	}

	close(jobs)
	wg.Wait()
	outputOutcomes(Metrics.Outcomes, localOutputDir)
	log.Println("Conversion run complete")
}

// worker is a function that processes CVE files from the jobs channel.
func worker(wg *sync.WaitGroup, jobs <-chan string, outDir string) {
	defer wg.Done()
	for path := range jobs {
		data, err := os.ReadFile(path)
		if err != nil {
			log.Printf("Failed to read file %s: %v", path, err)
			continue
		}

		var cve CVE
		if err := json.Unmarshal(data, &cve); err != nil {
			log.Printf("Failed to unmarshal JSON from %s: %v", path, err)
			continue
		}

		if cve.Metadata.Assigner == "Linux" && cve.Metadata.State == "PUBLISHED" {
			log.Printf("Processing %s...", cve.Metadata.ID)
			var logCleanup func()
			Logger, logCleanup = utility.CreateLoggerWrapper("cvelist-osv")
			defer logCleanup()

			var cve cves.CVE5
			if err = json.Unmarshal(data, &cve); err != nil {
				Logger.Fatalf("Failed to parse CVEList CVE JSON: %v", err)
			}

			// Perform the conversion and export the results.
			if err = cvelist2osv.ConvertAndExportCVEToOSV(cve, outDir); err != nil {
				Logger.Warnf("[%s]: Failed to generate an OSV record: %+v", cve.Metadata.CVEID, err)
				Metrics.Outcomes[cve.Metadata.CVEID] = ConversionUnknown
			} else {
				Metrics.Outcomes[cve.Metadata.CVEID] = Successful
			}

			// , "-cve_json", path, "-out_dir", outDir)
			// if output, err := cmd.CombinedOutput(); err != nil {
			// 	log.Printf("Error processing %s: %v\nOutput: %s", cve.Metadata.ID, err, string(output))
			// }
		}
	}
}
