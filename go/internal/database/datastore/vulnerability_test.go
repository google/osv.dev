package datastore

import (
	"context"
	"testing"

	"cloud.google.com/go/datastore"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/google/osv.dev/go/internal/models"
	"github.com/google/osv.dev/go/testutils"
)

func TestVulnerabilityStore_ListBySource(t *testing.T) {
	ctx := context.Background()
	dsClient := testutils.MustNewDatastoreClientForTesting(t)
	store := NewVulnerabilityStore(dsClient)

	vulns := []Vulnerability{
		{
			SourceID:    "source-a:path/1.json",
			IsWithdrawn: false,
		},
		{
			SourceID:    "source-a:path/2.json",
			IsWithdrawn: true,
		},
		{
			SourceID:    "source-b:path/3.json",
			IsWithdrawn: false,
		},
	}

	keys := []*datastore.Key{
		datastore.NameKey("Vulnerability", "ID-1", nil),
		datastore.NameKey("Vulnerability", "ID-2", nil),
		datastore.NameKey("Vulnerability", "ID-3", nil),
	}

	if _, err := dsClient.PutMulti(ctx, keys, vulns); err != nil {
		t.Fatalf("Failed to setup test data: %v", err)
	}

	tests := []struct {
		name          string
		source        string
		skipWithdrawn bool
		want          []*models.VulnSourceRef
	}{
		{
			name:          "Source A - Skip Withdrawn",
			source:        "source-a",
			skipWithdrawn: true,
			want: []*models.VulnSourceRef{
				{ID: "ID-1", Source: "source-a", Path: "path/1.json"},
			},
		},
		{
			name:          "Source A - Include Withdrawn",
			source:        "source-a",
			skipWithdrawn: false,
			want: []*models.VulnSourceRef{
				{ID: "ID-1", Source: "source-a", Path: "path/1.json"},
				{ID: "ID-2", Source: "source-a", Path: "path/2.json"},
			},
		},
		{
			name:          "Source B",
			source:        "source-b",
			skipWithdrawn: true,
			want: []*models.VulnSourceRef{
				{ID: "ID-3", Source: "source-b", Path: "path/3.json"},
			},
		},
		{
			name:          "Non-existent Source",
			source:        "source-c",
			skipWithdrawn: true,
			want:          []*models.VulnSourceRef{},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var got []*models.VulnSourceRef
			for entry, err := range store.ListBySource(ctx, tt.source, tt.skipWithdrawn) {
				if err != nil {
					t.Fatalf("ListBySource() error: %v", err)
				}
				got = append(got, entry)
			}

			sortOpt := cmpopts.SortSlices(func(a, b *models.VulnSourceRef) bool {
				return a.ID < b.ID
			})

			if diff := cmp.Diff(tt.want, got, cmpopts.EquateEmpty(), sortOpt); diff != "" {
				t.Errorf("ListBySource() mismatch (-want +got):\n%s", diff)
			}
		})
	}
}
