// Package main converts CVEs to OSV format in bulk.
package main

import (
	"encoding/json"
	"flag"
	"log/slog"
	"os"
	"path/filepath"
	"slices"
	"strings"
	"sync"

	"github.com/google/osv/vulnfeeds/cvelist2osv"
	"github.com/google/osv/vulnfeeds/cves"
	"github.com/google/osv/vulnfeeds/utility/logger"
)

var (
	repoDir        = flag.String("cve_repo", "cvelistV5", "CVEListV5 directory path")
	localOutputDir = flag.String("out_dir", "cvelist2osv", "Path to output results.")
	years          = flag.String("years", "2022,2023,2024,2025", "A comma-separated list of years to process.")
	workers        = flag.Int("workers", 30, "The number of concurrent workers to use for processing CVEs.")
	cnas           = flag.String("cnas", "Linux,GitHub_M", "A comma-separated list of CNAs to process.")
)

func main() {
	flag.Parse()
	logger.InitGlobalLogger()

	logger.Info("Commencing Linux CVE to OSV conversion run")
	if err := os.MkdirAll(*localOutputDir, 0755); err != nil {
		logger.Fatal("Failed to create local output directory", slog.Any("err", err))
	}

	jobs := make(chan string)
	var wg sync.WaitGroup

	cnaList := strings.Split(*cnas, ",")
	// Start the worker pool.
	for range *workers {
		wg.Add(1)
		go worker(&wg, jobs, *localOutputDir, cnaList)
	}

	// Discover files and send them to the workers.
	logger.Info("Starting conversion of CVEs...")

	yearList := strings.Split(*years, ",")
	for _, year := range yearList {
		yearDir := filepath.Join(*repoDir, "cves", year)
		if _, err := os.Stat(yearDir); os.IsNotExist(err) {
			logger.Info("Directory for year not found, skipping", slog.String("year", year))
			continue
		}

		logger.Info("Processing CVEs for year", slog.String("year", year))
		err := filepath.Walk(yearDir, func(path string, info os.FileInfo, err error) error {
			if err != nil {
				return err
			}
			if !info.IsDir() && strings.HasSuffix(info.Name(), ".json") {
				jobs <- path
			}

			return nil
		})
		if err != nil {
			logger.Info("Error walking directory for year", slog.String("year", year), slog.Any("err", err))
		}
	}

	close(jobs)
	wg.Wait()
	logger.Info("Conversion run complete")
}

// worker is a function that processes CVE files from the jobs channel.
func worker(wg *sync.WaitGroup, jobs <-chan string, outDir string, cnas []string) {
	defer wg.Done()
	for path := range jobs {
		data, err := os.ReadFile(path)
		if err != nil {
			logger.Info("Failed to read file", slog.String("path", path), slog.Any("err", err))
			continue
		}

		var cve cves.CVE5
		if err := json.Unmarshal(data, &cve); err != nil {
			logger.Info("Failed to unmarshal JSON", slog.String("path", path), slog.Any("err", err))
			continue
		}

		if slices.Contains(cnas, cve.Metadata.AssignerShortName) && cve.Metadata.State == "PUBLISHED" {
			logger.Info("Processing "+string(cve.Metadata.CVEID), slog.String("cve", string(cve.Metadata.CVEID)))

			osvFile, err := cvelist2osv.WriteOSVToFile(cve.Metadata.CVEID, outDir)
			defer osvFile.Close()

			metricsFile, err := cvelist2osv.WriteMetricToFile(cve.Metadata.CVEID, outDir)
			defer metricsFile.Close()

			cveId := cve.Metadata.CVEID
			// Perform the conversion and export the results.
			if err = cvelist2osv.ConvertAndExportCVEToOSV(cve, osvFile, metricsFile); err != nil {
				logger.Warn("Failed to generate an OSV record", slog.String("cve", string(cveId)), slog.Any("err", err))
			} else {
				metricsFile.Close()
				osvFile.Close()
				logger.Info("Generated OSV record for "+string(cveId), slog.String("cve", string(cveId)), slog.String("cna", cve.Metadata.AssignerShortName))
			}
		}
	}
}
